AWSTemplateFormatVersion: '2010-09-09'
Description: "Free-tier EC2 backend for TickTock Tasks with Nginx (reverse proxy) and automatic TLS via Let's Encrypt (Certbot) and Route53 DNS"

Parameters:
  DomainName:
    Type: String
    Description: "Base domain for your site (must be in the provided HostedZone). Example: ticktocktasks.com"
  ApiSubdomain:
    Type: String
    Default: api
    Description: "Subdomain for the backend (api -> api.<DomainName>)"
  HostedZoneId:
    Type: String
    Description: "Route53 Hosted Zone ID for the DomainName"
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: "VPC where the instance and security group will be created"
  SubnetId:
    Type: AWS::EC2::Subnet::Id
    Description: "Public subnet for the instance (must provide internet access and auto-assign public IP)"
  InstanceType:
    Type: String
    Default: t2.micro
    AllowedValues: [t2.micro, t3.micro]
    Description: "EC2 instance type (free-tier eligible: t2.micro)"
  KeyName:
    Type: String
    Default: ''
    Description: "Optional SSH key pair name to access the instance (leave empty to skip)"
  RepoUrl:
    Type: String
    Default: https://github.com/example/Todo_App.git
    Description: "Git repository URL containing this project. Must be accessible by the instance."
  AllowedOrigins:
    Type: String
    Default: https://ticktocktasks.com,https://www.ticktocktasks.com
    Description: "Comma-separated list of allowed frontend origins for CORS (e.g., your CloudFront domain and custom domain)"
  CreateApiDnsRecord:
    Type: String
    AllowedValues: ['true','false']
    Default: 'true'
    Description: "Whether to create the api.<DomainName> Route53 A record. Set 'false' to reuse existing DNS."
  LatestAmi:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64'
    Description: "Latest Amazon Linux 2023 AMI via SSM parameter"

Mappings:
  RegionMap:
    us-east-1:
      Ami: ami-05576a079321f21f8
    us-east-2:
      Ami: ami-08fb2ae774d2f6c48
    us-west-2:
      Ami: ami-0f3a42250e0e530d1
    eu-west-1:
      Ami: ami-089950bc622d39ed8

Conditions:
  HasKey: !Not [ !Equals [ !Ref KeyName, '' ] ]
  CreateApiDns: !Equals [ !Ref CreateApiDnsRecord, 'true' ]

Resources:
  BackendSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Allow HTTP/HTTPS"
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8443
          ToPort: 8443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Project
          Value: TickTockTasks

  BackendRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: TickTockBackendCloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                  - logs:DescribeLogGroups
                Resource: '*'
        - PolicyName: TickTockBackendDynamoDB
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:CreateTable
                  - dynamodb:DescribeTable
                  - dynamodb:ListTables
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:BatchWriteItem
                  - dynamodb:BatchGetItem
                Resource:
                  - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/ttt-*'

  BackendInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [ !Ref BackendRole ]

  BackendLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/TickTock/Backend-${DomainName}'
      RetentionInDays: 14
      Tags:
        - Key: Project
          Value: TickTockTasks

  BackendEc2:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmi
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref BackendInstanceProfile
      KeyName: !If [HasKey, !Ref KeyName, !Ref AWS::NoValue]
      NetworkInterfaces:
        - DeviceIndex: 0
          AssociatePublicIpAddress: true
          SubnetId: !Ref SubnetId
          GroupSet: [ !Ref BackendSecurityGroup ]
      Tags:
        - Key: Name
          Value: TickTockTasks-Backend
        - Key: Project
          Value: TickTockTasks
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          # Install docker, compose plugin, git, jq (Nginx runs via Docker)
          (dnf update -y || yum update -y) || true
          (dnf install -y docker docker-compose-plugin git jq || yum install -y docker git jq) || true
          # Fallback for compose if plugin missing
          if ! command -v docker-compose >/dev/null 2>&1; then
            if ! docker compose version >/dev/null 2>&1; then
              curl -L "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose || true
            fi
          fi
          systemctl enable --now docker

          # Clone repo
          mkdir -p /opt/ticktock
          if [ ! -d /opt/ticktock/.git ]; then
            git clone "${RepoUrl}" /opt/ticktock || true
          fi
          cd /opt/ticktock
          chmod +x ./backend-up.sh || true

          # Configure Docker logging and containerized Nginx reverse proxy via override before first start
          cat > /opt/ticktock/docker-compose.override.yml <<OVR
          version: '3.8'
          services:
            backend:
              logging:
                driver: awslogs
                options:
                  awslogs-region: ${AWS::Region}
                  awslogs-group: /TickTock/Backend-${DomainName}
                  awslogs-create-group: "true"
            nginx:
              image: nginx:alpine
              container_name: ttt-nginx
              restart: unless-stopped
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - /opt/ticktock/nginx.conf:/etc/nginx/nginx.conf
                - letsencrypt:/etc/letsencrypt
                - certbot_challenges:/var/www/certbot
              depends_on:
                - backend
              healthcheck:
                test: ["CMD-SHELL", "wget -qO- --no-check-certificate https://127.0.0.1/healthz >/dev/null || exit 1"]
                interval: 30s
                timeout: 5s
                retries: 3
                start_period: 30s
              logging:
                driver: awslogs
                options:
                  awslogs-region: ${AWS::Region}
                  awslogs-group: /TickTock/Backend-${DomainName}
                  awslogs-create-group: "true"
            certbot:
              image: certbot/certbot
              container_name: ttt-certbot
              volumes:
                - letsencrypt:/etc/letsencrypt
                - certbot_challenges:/var/www/certbot
            autoheal:
              image: willfarrell/autoheal
              container_name: ttt-autoheal
              restart: unless-stopped
              environment:
                - AUTOHEAL_CONTAINER_LABEL=all
                - AUTOHEAL_INTERVAL=10
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock
          volumes:
            letsencrypt:
            certbot_challenges:
          OVR

          # Prepare env and start backend (write .env with first origin), then widen to all AllowedOrigins
          FRONT_ORIGIN="$(echo "${AllowedOrigins}" | cut -d',' -f1)"
          export CORS_ORIGIN="${AllowedOrigins}"
          export DDB_REGION="${AWS::Region}"
          ./backend-up.sh "$FRONT_ORIGIN" || true
          if [ -f .env ]; then
            sed -i "s|^CORS_ORIGIN=.*|CORS_ORIGIN=${AllowedOrigins}|" .env || true
            if grep -q '^REDIRECT_HTTP_TO_HTTPS=' .env; then
              sed -i 's#^REDIRECT_HTTP_TO_HTTPS=.*#REDIRECT_HTTP_TO_HTTPS=false#' .env || true
            else
              echo 'REDIRECT_HTTP_TO_HTTPS=false' >> .env
            fi
            if grep -q '^DDB_REGION=' .env; then
              sed -i "s#^DDB_REGION=.*#DDB_REGION=${AWS::Region}#" .env || true
            else
              echo 'DDB_REGION=${AWS::Region}' >> .env
            fi
          fi

          # Write initial Nginx config (HTTP only + ACME webroot) so proxy is ready immediately
          cat >/opt/ticktock/nginx.conf <<CFG
          user  nginx;
          worker_processes  auto;
          error_log  /var/log/nginx/error.log warn;
          pid        /var/run/nginx.pid;
          events { worker_connections 1024; }
          http {
            include       /etc/nginx/mime.types;
            default_type  application/octet-stream;
            sendfile        on;
            keepalive_timeout 65;
            upstream ticktock_backend { server backend:8080; }
            server {
              listen 80 default_server;
              server_name ${ApiSubdomain}.${DomainName};
              location ^~ /.well-known/acme-challenge/ { root /var/www/certbot; default_type "text/plain"; }
              location = /healthz { proxy_set_header Host \$host; proxy_pass http://ticktock_backend/healthz; }
              location / {
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_buffering off;
                proxy_request_buffering off;
                proxy_read_timeout 60s;
                proxy_send_timeout 60s;
                proxy_pass http://ticktock_backend;
              }
            }
          }
          CFG

          # Start containers (ensure backend + nginx)
          docker rm -f ttt-nginx ttt-autoheal ticktock-caddy 2>/dev/null || true
          if command -v docker-compose >/dev/null 2>&1; then
            docker-compose up -d || true
          else
            docker compose up -d || true
          fi

          # Obtain/renew certificate via Certbot webroot (non-fatal if it fails)
          if command -v docker-compose >/dev/null 2>&1; then
            docker-compose run --rm certbot certonly --webroot -w /var/www/certbot -d ${ApiSubdomain}.${DomainName} --agree-tos --email admin@${DomainName} -n || true
          else
            docker compose run --rm certbot certonly --webroot -w /var/www/certbot -d ${ApiSubdomain}.${DomainName} --agree-tos --email admin@${DomainName} -n || true
          fi


          # Write HTTPS-enabled Nginx config
          cat >/opt/ticktock/nginx.conf <<CFG
          user  nginx;
          worker_processes  auto;
          error_log  /var/log/nginx/error.log warn;
          pid        /var/run/nginx.pid;
          events { worker_connections 1024; }
          http {
            include       /etc/nginx/mime.types;
            default_type  application/octet-stream;
            sendfile        on;
            keepalive_timeout 65;
            upstream ticktock_backend { server backend:8080; }
            server {
              listen 80;
              server_name ${ApiSubdomain}.${DomainName};
              location ^~ /.well-known/acme-challenge/ { root /var/www/certbot; default_type "text/plain"; }
              return 301 https://\$host\$request_uri;
            }
            server {
              listen 443 ssl http2;
              server_name ${ApiSubdomain}.${DomainName};
              ssl_certificate /etc/letsencrypt/live/${ApiSubdomain}.${DomainName}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${ApiSubdomain}.${DomainName}/privkey.pem;
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers HIGH:!aNULL:!MD5;
              location = /healthz { proxy_set_header Host \$host; proxy_pass http://ticktock_backend/healthz; }
              location / {
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_buffering off;
                proxy_request_buffering off;
                proxy_read_timeout 60s;
                proxy_send_timeout 60s;
                proxy_pass http://ticktock_backend;
              }
            }
          }
          CFG

          # Reload Nginx to pick up HTTPS config
          if command -v docker-compose >/dev/null 2>&1; then
            docker-compose exec -T nginx nginx -s reload || docker-compose restart nginx || true
          else
            docker compose exec -T nginx nginx -s reload || docker compose restart nginx || true
          fi

          # Wait for Nginx to listen on 80/443
          for i in $(seq 1 60); do
            if ss -ltn 2>/dev/null | grep -E 'LISTEN.+:(80|443)'; then
              break
            fi
            sleep 2
          done

  ApiRecord:
    Condition: CreateApiDns
    Type: AWS::Route53::RecordSet
    DependsOn: BackendEc2
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub '${ApiSubdomain}.${DomainName}'
      Type: A
      TTL: '60'
      ResourceRecords:
        - !GetAtt BackendEc2.PublicIp

Outputs:
  InstanceId:
    Description: EC2 instance ID
    Value: !Ref BackendEc2
  PublicIp:
    Description: EC2 public IP
    Value: !GetAtt BackendEc2.PublicIp
  ApiDomainName:
    Description: Backend API domain name
    Value: !Sub '${ApiSubdomain}.${DomainName}'
  BackendEndpoint:
    Description: HTTPS endpoint for backend
    Value: !Sub 'https://${ApiSubdomain}.${DomainName}'
