name: Backend Deploy to EC2 (ticktocktasks.com)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  STACK_NAME: tt-backend
  DOMAIN_NAME: ticktocktasks.com
  VPC_ID: vpc-0fbbe4d79713c387a

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-backend-deploy


      - name: Install AWS CLI v2
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2

      - name: Ensure or discover a public subnet with IGW route
        id: subnet
        shell: bash
        run: |
          set -euo pipefail
          # Allow explicit override via secret
          if [ -n "${{ secrets.SUBNET_ID }}" ]; then
            echo "Using SUBNET_ID from secret"
            echo "id=${{ secrets.SUBNET_ID }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Looking for public subnets in VPC $VPC_ID (MapPublicIpOnLaunch=true and route to Internet Gateway)..."
          PUB_SUBNETS=$(aws ec2 describe-subnets \
            --filters Name=vpc-id,Values=$VPC_ID \
            --query 'Subnets[?MapPublicIpOnLaunch==`true`].SubnetId' \
            --output text | tr '\n' ' ')

          pick_subnet=""
          for sn in $PUB_SUBNETS; do
            # Find the route table associated with this subnet (explicit or main)
            RT_ID=$(aws ec2 describe-route-tables \
              --filters Name=association.subnet-id,Values=$sn Name=vpc-id,Values=$VPC_ID \
              --query 'RouteTables[0].RouteTableId' --output text || true)
            if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
              # fall back to main RT for the VPC
              RT_ID=$(aws ec2 describe-route-tables --filters Name=vpc-id,Values=$VPC_ID Name=association.main,Values=true \
                --query 'RouteTables[0].RouteTableId' --output text || true)
            fi
            if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
              continue
            fi
            # Check for a route to an Internet Gateway
            HAS_IGW=$(aws ec2 describe-route-tables --route-table-ids "$RT_ID" \
              --query 'RouteTables[0].Routes[?contains(GatewayId, `igw-`) && DestinationCidrBlock==`0.0.0.0/0` ] | length(@)' --output text || echo 0)
            if [ "$HAS_IGW" != "0" ]; then
              pick_subnet="$sn"
              break
            fi
          done

          if [ -n "$pick_subnet" ]; then
            echo "Selected existing public subnet: $pick_subnet"
            echo "id=$pick_subnet" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "No suitable public subnet found. Ensuring required resources in VPC $VPC_ID..."
          # 1) Ensure an Internet Gateway is attached to the VPC
          IGW_ID=$(aws ec2 describe-internet-gateways --filters Name=attachment.vpc-id,Values=$VPC_ID \
            --query 'InternetGateways[0].InternetGatewayId' --output text || true)
          if [ -z "$IGW_ID" ] || [ "$IGW_ID" = "None" ]; then
            echo "Creating and attaching Internet Gateway..."
            IGW_ID=$(aws ec2 create-internet-gateway --query 'InternetGateway.InternetGatewayId' --output text)
            aws ec2 attach-internet-gateway --internet-gateway-id "$IGW_ID" --vpc-id "$VPC_ID"
          else
            echo "Found existing IGW: $IGW_ID"
          fi

          # 2) Choose a subnet in the VPC (prefer one already public, else first available)
          ALL_SUBNETS=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC_ID --query 'Subnets[].SubnetId' --output text | tr '\n' ' ')
          if [ -z "$ALL_SUBNETS" ]; then
            echo "ERROR: VPC $VPC_ID has no subnets. Please create at least one subnet or provide secrets.SUBNET_ID." >&2
            exit 1
          fi
          # Prefer a MapPublicIpOnLaunch=true subnet if any
          pick_subnet=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC_ID Name=map-public-ip-on-launch,Values=true \
            --query 'Subnets[0].SubnetId' --output text || true)
          if [ -z "$pick_subnet" ] || [ "$pick_subnet" = "None" ]; then
            # fall back to the first subnet in the VPC
            pick_subnet=$(echo $ALL_SUBNETS | awk '{print $1}')
          fi
          echo "Using subnet: $pick_subnet"

          # 3) Ensure MapPublicIpOnLaunch=true for the picked subnet
          MPL=$(aws ec2 describe-subnets --subnet-ids "$pick_subnet" --query 'Subnets[0].MapPublicIpOnLaunch' --output text)
          if [ "$MPL" != "True" ]; then
            echo "Enabling MapPublicIpOnLaunch on $pick_subnet"
            aws ec2 modify-subnet-attribute --subnet-id "$pick_subnet" --map-public-ip-on-launch
          fi

          # 4) Ensure the subnet has a route to the IGW
          RT_ID=$(aws ec2 describe-route-tables --filters Name=association.subnet-id,Values=$pick_subnet \
            --query 'RouteTables[0].RouteTableId' --output text || true)
          if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
            # Try main RT
            RT_ID=$(aws ec2 describe-route-tables --filters Name=vpc-id,Values=$VPC_ID Name=association.main,Values=true \
              --query 'RouteTables[0].RouteTableId' --output text || true)
          fi
          if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
            echo "Creating a new route table in the VPC and associating it with the subnet"
            RT_ID=$(aws ec2 create-route-table --vpc-id "$VPC_ID" --query 'RouteTable.RouteTableId' --output text)
            aws ec2 associate-route-table --route-table-id "$RT_ID" --subnet-id "$pick_subnet" >/dev/null
          else
            echo "Using route table $RT_ID for subnet $pick_subnet"
          fi

          # Ensure default route to the IGW exists (idempotent)
          set +e
          aws ec2 create-route --route-table-id "$RT_ID" --destination-cidr-block 0.0.0.0/0 --gateway-id "$IGW_ID" >/dev/null 2>&1
          RC=$?
          set -e
          if [ $RC -eq 0 ]; then
            echo "Added default route to IGW $IGW_ID in RT $RT_ID"
          else
            echo "Default route may already exist in RT $RT_ID; continuing"
          fi

          echo "Selected/Prepared public subnet: $pick_subnet"
          echo "id=$pick_subnet" >> $GITHUB_OUTPUT

      - name: Deploy/Update backend CloudFormation stack
        env:
          SUBNET_ID: ${{ steps.subnet.outputs.id }}
        run: |
          set -euo pipefail
          TPL=infrastructure/backend/template.yaml
          REPO_URL="${{ github.server_url }}/${{ github.repository }}.git"
          aws cloudformation deploy \
            --region "$AWS_REGION" \
            --stack-name "$STACK_NAME" \
            --template-file "$TPL" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --parameter-overrides \
              DomainName="$DOMAIN_NAME" \
              HostedZoneId="Z08471201NA2PN7ERBIB7" \
              VpcId="$VPC_ID" \
              SubnetId="$SUBNET_ID" \
              AllowedOrigins="http://www.$DOMAIN_NAME,https://www.$DOMAIN_NAME" \
              RepoUrl="$REPO_URL" \
              CreateApiDnsRecord="true"

      - name: Show backend outputs
        run: |
          aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[].[OutputKey,OutputValue]' --output table

      - name: Redeploy backend on EC2 via SSM (git pull, restart containers)
        id: ssm
        env:
          REPO_URL: "${{ github.server_url }}/${{ github.repository }}.git"
        run: |
          set -euo pipefail
          echo "Ensuring CloudFormation stack is ready and fetching EC2 InstanceId..."

          # Wait up to ~3 minutes for stack to reach a good state and expose outputs
          ATTEMPTS=30
          SLEEP=6
          for i in $(seq 1 $ATTEMPTS); do
            STATUS=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "Unknown")
            INSTANCE_ID=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='InstanceId'].OutputValue" --output text 2>/dev/null || true)

            echo "Attempt $i/$ATTEMPTS: StackStatus=$STATUS InstanceId=${INSTANCE_ID:-}"

            case "$STATUS" in
              CREATE_COMPLETE|UPDATE_COMPLETE|UPDATE_COMPLETE_CLEANUP_IN_PROGRESS)
                if [ -n "${INSTANCE_ID:-}" ] && [ "$INSTANCE_ID" != "None" ]; then
                  break
                fi
                ;;
              ROLLBACK_COMPLETE|ROLLBACK_FAILED|UPDATE_ROLLBACK_COMPLETE|UPDATE_ROLLBACK_FAILED|CREATE_FAILED|UPDATE_FAILED)
                echo "Stack is in a failed state: $STATUS" >&2
                echo "Recent stack events:" >&2
                aws cloudformation describe-stack-events --region "$AWS_REGION" --stack-name "$STACK_NAME" \
                  --query 'StackEvents[0:20].[Timestamp,ResourceStatus,LogicalResourceId,ResourceType,ResourceStatusReason]' --output table || true
                exit 1
                ;;
            esac

            if [ $i -lt $ATTEMPTS ]; then sleep $SLEEP; fi
          done

          if [ -z "${INSTANCE_ID:-}" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "Timed out waiting for InstanceId in stack outputs for $STACK_NAME" >&2
            echo "Final stack status: $STATUS" >&2
            aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" \
              --query 'Stacks[0].[StackName,StackStatus,StackStatusReason]' --output table || true
            exit 1
          fi

          echo "InstanceId: $INSTANCE_ID"

          # Build SSM parameters JSON safely and send command (avoid cli-input-json file parsing issues)
          PARAM='{
            "commands": [
              "set -euo pipefail",
              "echo [SSM] Starting backend redeploy at $(date -Is)",
              "mkdir -p /opt/app", 
              "if [ -d /opt/app/.git ]; then echo '[SSM] /opt/app repo exists'; else echo '[SSM] Cloning repo to /opt/app'; rm -rf /opt/app; git clone ${REPO_URL} /opt/app; fi",
              "cd /opt/app",
              "git fetch --all --prune || true",
              "git reset --hard origin/main || true",
              "if docker compose version >/dev/null 2>&1; then DC='docker compose'; elif command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else echo '[SSM] docker compose not found; installing legacy docker-compose'; curl -L 'https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)' -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose; DC='docker-compose'; fi",
              "$DC down || true",
              "$DC pull || true",
              "$DC build --pull || true",
              "$DC up -d",
              "$DC ps",
              "echo [SSM] Completed backend redeploy at $(date -Is)"
            ]
          }'

          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "TickTockTasks backend redeploy from GitHub" \
            --cli-binary-format raw-in-base64-out \
            --parameters "$PARAM" \
            --query 'Command.CommandId' --output text)
          echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT
          echo "Sent SSM command: $CMD_ID; waiting for completion..."

          set +e
          aws ssm wait command-executed --region "$AWS_REGION" --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          WAITER_RC=$?
          set -e

          STATUS=$(aws ssm list-commands --region "$AWS_REGION" --command-id "$CMD_ID" --query 'Commands[0].Status' --output text)
          echo "SSM command status: $STATUS (wait rc=$WAITER_RC)"
          echo "Fetching SSM output (last 200 lines)..."
          aws ssm list-command-invocations --region "$AWS_REGION" --command-id "$CMD_ID" --details \
            --query 'CommandInvocations[0].CommandPlugins[0].Output' --output text | tail -n 200 || true

          if [ "$STATUS" != "Success" ]; then
            echo "SSM redeploy failed with status: $STATUS" >&2
            exit 1
          fi

      - name: Public health checks (WWW + API)
        run: |
          set -euo pipefail
          set +e
          for i in {1..10}; do
            echo "Attempt $i: http://www.${DOMAIN_NAME}/";
            curl -fsS -H 'Cache-Control: no-cache' "http://www.${DOMAIN_NAME}/" && OK1=1 && break || sleep 3;
          done
          for i in {1..10}; do
            echo "Attempt $i: http://www.api.${DOMAIN_NAME}/healthz";
            curl -fsS -H 'Cache-Control: no-cache' "http://www.api.${DOMAIN_NAME}/healthz" && OK2=1 && break || sleep 3;
          done
          set -e
          if [ -z "${OK1:-}" ] || [ -z "${OK2:-}" ]; then
            echo "One or more public health checks failed" >&2
            exit 1
          fi

      - name: Internal health check via SSM
        run: |
          set -euo pipefail
          INSTANCE_ID=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='InstanceId'].OutputValue" --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "Could not resolve InstanceId from stack outputs" >&2
            exit 1
          fi

          PARAM='{
            "commands": [
              "set -euo pipefail",
              "echo [SSM] docker compose ps:",
              "(cd /opt/app 2>/dev/null && (docker compose ps || docker-compose ps || true)) || true",
              "echo [SSM] curl localhost:8080/healthz:",
              "curl -sfS http://127.0.0.1:8080/healthz || true",
              "echo [SSM] curl nginx /healthz:",
              "curl -sfS http://127.0.0.1/healthz || true",
              "echo [SSM] backend logs (last 200 lines):",
              "docker logs --tail=200 ttt-backend || true"
            ]
          }'

          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "TickTockTasks backend health check" \
            --cli-binary-format raw-in-base64-out \
            --parameters "$PARAM" \
            --query 'Command.CommandId' --output text)

          set +e
          aws ssm wait command-executed --region "$AWS_REGION" --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          WAITER_RC=$?
          set -e

          STATUS=$(aws ssm list-commands --region "$AWS_REGION" --command-id "$CMD_ID" --query 'Commands[0].Status' --output text)
          echo "SSM health check status: $STATUS (wait rc=$WAITER_RC)"
          aws ssm list-command-invocations --region "$AWS_REGION" --command-id "$CMD_ID" --details \
            --query 'CommandInvocations[0].CommandPlugins[0].Output' --output text | tail -n 400 || true

          if [ "$STATUS" != "Success" ] && [ "$STATUS" != "SuccessAndCommandExpectedOutputNotAvailable" ]; then
            echo "SSM health check failed with status: $STATUS" >&2
            exit 1
          fi
