name: Backend Deploy to EC2 (ticktocktasks.com)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  STACK_NAME: tt-backend
  DOMAIN_NAME: ticktocktasks.com
  VPC_ID: vpc-0fbbe4d79713c387a

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-backend-deploy


      - name: Install AWS CLI v2
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2

      - name: Find a subnet in the VPC (prefer public with IGW route)
        id: subnet
        shell: bash
        run: |
          set -euo pipefail
          # Allow explicit override via secret
          if [ -n "${{ secrets.SUBNET_ID }}" ]; then
            echo "Using SUBNET_ID from secret"
            echo "id=${{ secrets.SUBNET_ID }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Looking for public subnets in VPC $VPC_ID (MapPublicIpOnLaunch=true and route to Internet Gateway)..."
          PUB_SUBNETS=$(aws ec2 describe-subnets \
            --filters Name=vpc-id,Values=$VPC_ID \
            --query 'Subnets[?MapPublicIpOnLaunch==`true`].SubnetId' \
            --output text | tr '\n' ' ')

          pick_subnet=""
          for sn in $PUB_SUBNETS; do
            # Find the route table associated with this subnet
            RT_ID=$(aws ec2 describe-route-tables \
              --filters Name=association.subnet-id,Values=$sn \
              --query 'RouteTables[0].RouteTableId' --output text || true)
            if [ -z "$RT_ID" ] || [ "$RT_ID" = "None" ]; then
              continue
            fi
            # Check for a route to an Internet Gateway
            HAS_IGW=$(aws ec2 describe-route-tables --route-table-ids "$RT_ID" \
              --query 'RouteTables[0].Routes[?contains(GatewayId, `igw-`)] | length(@)' --output text || echo 0)
            if [ "$HAS_IGW" != "0" ]; then
              pick_subnet="$sn"
              break
            fi
          done

          if [ -n "$pick_subnet" ]; then
            echo "Selected public subnet: $pick_subnet"
            echo "id=$pick_subnet" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "ERROR: No public subnet with an Internet Gateway route found in VPC $VPC_ID." >&2
          echo "Please ensure there is at least one public subnet (MapPublicIpOnLaunch=true) with a route to an Internet Gateway, or set secrets.SUBNET_ID to an appropriate subnet." >&2
          exit 1

      - name: Deploy/Update backend CloudFormation stack
        env:
          SUBNET_ID: ${{ steps.subnet.outputs.id }}
        run: |
          set -euo pipefail
          TPL=infrastructure/backend/template.yaml
          REPO_URL="${{ github.server_url }}/${{ github.repository }}.git"
          aws cloudformation deploy \
            --region "$AWS_REGION" \
            --stack-name "$STACK_NAME" \
            --template-file "$TPL" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --parameter-overrides \
              DomainName="$DOMAIN_NAME" \
              HostedZoneId="Z08471201NA2PN7ERBIB7" \
              VpcId="$VPC_ID" \
              SubnetId="$SUBNET_ID" \
              AllowedOrigins="https://$DOMAIN_NAME,https://www.$DOMAIN_NAME" \
              RepoUrl="$REPO_URL" \
              CreateApiDnsRecord="true"

      - name: Show backend outputs
        run: |
          aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[].[OutputKey,OutputValue]' --output table

      - name: Redeploy backend on EC2 via SSM (git pull, restart containers)
        id: ssm
        env:
          REPO_URL: "${{ github.server_url }}/${{ github.repository }}.git"
        run: |
          set -euo pipefail
          echo "Fetching EC2 InstanceId from stack outputs..."
          INSTANCE_ID=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='InstanceId'].OutputValue" --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "Could not find InstanceId output for stack $STACK_NAME" >&2
            exit 1
          fi
          echo "InstanceId: $INSTANCE_ID"

          # Compose robust SSM commands as JSON (avoids brittle quoting)
          cat > /tmp/redeploy-send.json <<JSON
          {
            "DocumentName": "AWS-RunShellScript",
            "Comment": "TickTockTasks backend redeploy from GitHub",
            "InstanceIds": ["$INSTANCE_ID"],
            "Parameters": {
              "commands": [
                "set -euo pipefail",
                "echo [SSM] Starting backend redeploy at $(date -Is)",
                "if [ -d /opt/app/.git ]; then cd /opt/app; git fetch --all --prune; git reset --hard origin/main; else rm -rf /opt/app.tmp; mkdir -p /opt/app.tmp; git clone ${REPO_URL} /opt/app.tmp; rm -rf /opt/app; mv /opt/app.tmp /opt/app; fi",
                "if [ -f /opt/app/backend/docker-compose.yml ]; then CDIR=/opt/app/backend; elif [ -f /opt/app/docker-compose.yml ]; then CDIR=/opt/app; else echo '[SSM] No docker-compose.yml found' >&2; exit 3; fi",
                "cd $CDIR",
                "if docker compose version >/dev/null 2>&1; then DC='docker compose'; else DC='docker-compose'; fi",
                "$DC down || true",
                "$DC pull || true",
                "$DC build --pull || true",
                "$DC up -d",
                "$DC ps",
                "echo [SSM] Completed backend redeploy at $(date -Is)"
              ]
            }
          }
          JSON

          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --cli-input-json file:///tmp/redeploy-send.json \
            --query 'Command.CommandId' --output text)
          echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT
          echo "Sent SSM command: $CMD_ID; waiting for completion..."

          set +e
          aws ssm wait command-executed --region "$AWS_REGION" --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          WAITER_RC=$?
          set -e

          STATUS=$(aws ssm list-commands --region "$AWS_REGION" --command-id "$CMD_ID" --query 'Commands[0].Status' --output text)
          echo "SSM command status: $STATUS (wait rc=$WAITER_RC)"
          echo "Fetching SSM output (last 200 lines)..."
          aws ssm list-command-invocations --region "$AWS_REGION" --command-id "$CMD_ID" --details \
            --query 'CommandInvocations[0].CommandPlugins[0].Output' --output text | tail -n 200 || true

          if [ "$STATUS" != "Success" ]; then
            echo "SSM redeploy failed with status: $STATUS" >&2
            exit 1
          fi

      - name: Public health checks (CloudFront / API)
        run: |
          set -euo pipefail
          set +e
          for i in {1..10}; do
            echo "Attempt $i: https://${DOMAIN_NAME}/api/healthz";
            curl -fsS -H 'Cache-Control: no-cache' "https://${DOMAIN_NAME}/api/healthz" && OK1=1 && break || sleep 3;
          done
          for i in {1..10}; do
            echo "Attempt $i: https://api.${DOMAIN_NAME}/healthz";
            curl -fsS -H 'Cache-Control: no-cache' "https://api.${DOMAIN_NAME}/healthz" && OK2=1 && break || sleep 3;
          done
          for i in {1..10}; do
            echo "Attempt $i: http://api.${DOMAIN_NAME}/healthz";
            curl -fsS -H 'Cache-Control: no-cache' "http://api.${DOMAIN_NAME}/healthz" && OK3=1 && break || sleep 3;
          done
          set -e
          if [ -z "${OK1:-}" ] && [ -z "${OK2:-}" ] && [ -z "${OK3:-}" ]; then
            echo "All public health checks failed" >&2
            exit 1
          fi

      - name: Internal health check via SSM
        run: |
          set -euo pipefail
          INSTANCE_ID=$(aws cloudformation describe-stacks --region "$AWS_REGION" --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='InstanceId'].OutputValue" --output text)

          cat > /tmp/health-commands.json <<JSON
          {
            "commands": [
              "set -euo pipefail",
              "echo [SSM] docker compose ps:",
              "(cd /opt/app/backend 2>/dev/null && (docker compose ps || docker-compose ps || true)) || true",
              "echo [SSM] curl localhost:8080/healthz:",
              "curl -sfS http://127.0.0.1:8080/healthz || true",
              "echo [SSM] curl nginx /healthz:",
              "curl -sfS http://127.0.0.1/healthz || true",
              "echo [SSM] backend logs (last 200 lines):",
              "docker logs --tail=200 ttt-backend || true"
            ]
          }
          JSON

          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "TickTockTasks backend health check" \
            --parameters file:///tmp/health-commands.json \
            --query 'Command.CommandId' --output text)

          set +e
          aws ssm wait command-executed --region "$AWS_REGION" --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          WAITER_RC=$?
          set -e

          STATUS=$(aws ssm list-commands --region "$AWS_REGION" --command-id "$CMD_ID" --query 'Commands[0].Status' --output text)
          echo "SSM health check status: $STATUS (wait rc=$WAITER_RC)"
          aws ssm list-command-invocations --region "$AWS_REGION" --command-id "$CMD_ID" --details \
            --query 'CommandInvocations[0].CommandPlugins[0].Output' --output text | tail -n 400 || true

          if [ "$STATUS" != "Success" ] && [ "$STATUS" != "SuccessAndCommandExpectedOutputNotAvailable" ]; then
            echo "SSM health check failed with status: $STATUS" >&2
            exit 1
          fi
