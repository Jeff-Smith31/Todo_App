name: Deploy TickTock EC2 + EIP (from constants)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          set -euo pipefail
          YQ_VERSION=v4.44.3
          BINARY=yq_linux_amd64
          curl -sSL -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${BINARY}"
          chmod +x /usr/local/bin/yq
          yq --version

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-ttt-deploy

      - name: Parse deploy/constants.yaml
        id: const
        run: |
          set -euo pipefail
          C=deploy/constants.yaml
          echo "Constants file:\n$(cat $C)"
          echo "region=$(yq -r '.Region' $C)" >> $GITHUB_OUTPUT
          echo "account=$(yq -r '.AccountId' $C)" >> $GITHUB_OUTPUT
          echo "domain=$(yq -r '.DomainName' $C)" >> $GITHUB_OUTPUT
          echo "hz=$(yq -r '.HostedZoneId' $C)" >> $GITHUB_OUTPUT
          echo "itype=$(yq -r '.InstanceType' $C)" >> $GITHUB_OUTPUT
          echo "apisub=$(yq -r '.ApiSubdomain' $C)" >> $GITHUB_OUTPUT
          echo "wwwsub=$(yq -r '.WwwSubdomain' $C)" >> $GITHUB_OUTPUT
          # Derive the actual repo URL from the current GitHub context to ensure EC2 clones the right code
          echo "repo=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git" >> $GITHUB_OUTPUT
          echo "stack=$(yq -r '.StackName' $C)" >> $GITHUB_OUTPUT
          echo "keyname=$(yq -r '.KeyName' $C)" >> $GITHUB_OUTPUT

      - name: Set region
        run: echo "AWS_REGION=${{ steps.const.outputs.region }}" >> $GITHUB_ENV

      - name: Install AWS CLI v2
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2

      - name: Deploy CloudFormation stack
        run: |
          set -euo pipefail
          TEMPLATE=deploy/cfn/stack.yaml
          aws cloudformation deploy \
            --region "${{ steps.const.outputs.region }}" \
            --stack-name "${{ steps.const.outputs.stack }}" \
            --template-file "$TEMPLATE" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --parameter-overrides \
              AccountId="${{ steps.const.outputs.account }}" \
              Region="${{ steps.const.outputs.region }}" \
              DomainName="${{ steps.const.outputs.domain }}" \
              HostedZoneId="${{ steps.const.outputs.hz }}" \
              InstanceType="${{ steps.const.outputs.itype }}" \
              ApiSubdomain="${{ steps.const.outputs.apisub }}" \
              WwwSubdomain="${{ steps.const.outputs.wwwsub }}" \
              RepoUrl="${{ steps.const.outputs.repo }}" \
              KeyName="${{ steps.const.outputs.keyname }}"

      - name: Show outputs
        id: show
        run: |
          aws cloudformation describe-stacks \
            --region "${{ steps.const.outputs.region }}" \
            --stack-name "${{ steps.const.outputs.stack }}" \
            --query 'Stacks[0].Outputs[].[OutputKey,OutputValue]' --output table
          IID=$(aws cloudformation describe-stacks \
            --region "${{ steps.const.outputs.region }}" \
            --stack-name "${{ steps.const.outputs.stack }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`InstanceId`].OutputValue' --output text)
          echo "instance_id=$IID" >> $GITHUB_OUTPUT

      - name: Bootstrap instance via SSM (ensure docker stack is running)
        if: steps.show.outputs.instance_id != ''
        run: |
          set -euo pipefail
          IID="${{ steps.show.outputs.instance_id }}"
          REGION="${{ steps.const.outputs.region }}"
          REPO_URL="${{ steps.const.outputs.repo }}"
          DOMAIN="${{ steps.const.outputs.domain }}"
          API_SUB="${{ steps.const.outputs.apisub }}"

          # Build the command script with runtime variables injected at the top
          cat > commands.sh <<'EOS'
          #!/bin/bash
          set -euxo pipefail
          exec >/var/log/ttt-ssm-bootstrap.log 2>&1
          yum update -y || true
          command -v docker >/dev/null 2>&1 || amazon-linux-extras install docker -y || yum install -y docker || true
          systemctl enable docker || true
          systemctl start docker || true
          if ! command -v docker-compose >/dev/null 2>&1; then
            curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
          fi
          mkdir -p /opt/app
          if [ ! -d /opt/app/.git ]; then
            rm -rf /opt/app
            git clone "$REPO_URL" /opt/app
          fi
          cd /opt/app
          mkdir -p /opt/app/letsencrypt /opt/app/certbot_challenges
          cat > .env <<EOF
          DOMAIN_NAME=$DOMAIN
          CORS_ORIGIN=http://$DOMAIN,https://$DOMAIN,http://www.$DOMAIN,https://www.$DOMAIN
          AWS_REGION=$REGION
          DDB_REGION=$REGION
          EOF
          /usr/local/bin/docker-compose pull || true
          docker run --rm -e AWS_REGION=$REGION -e AWS_DEFAULT_REGION=$REGION \
            -v /opt/app/letsencrypt:/etc/letsencrypt -v /opt/app/certbot_challenges:/var/www/certbot \
            certbot/dns-route53 certonly --dns-route53 \
            -d $DOMAIN -d www.$DOMAIN -d $API_SUB.$DOMAIN -d www.$API_SUB.$DOMAIN \
            --non-interactive --agree-tos -m admin@$DOMAIN || true
          /usr/local/bin/docker-compose up -d
          EOS

          # Prepend variable exports so the script has values when executed on the instance
          {
            echo "REPO_URL=$REPO_URL";
            echo "REGION=$REGION";
            echo "DOMAIN=$DOMAIN";
            echo "API_SUB=$API_SUB";
            cat commands.sh;
          } > commands.withvars.sh

          chmod +x commands.withvars.sh

          # Convert the script into a JSON array of lines for AWS-RunShellScript
          CMDS_JSON=$(jq -Rs 'split("\n") | map(select(length>0))' commands.withvars.sh)

          # Write parameters to a JSON file to avoid shell parsing issues with special characters
          jq -n --argjson cmds "$CMDS_JSON" '{commands: $cmds}' > commands.params.json

          aws ssm send-command \
            --region "$REGION" \
            --instance-ids "$IID" \
            --document-name "AWS-RunShellScript" \
            --parameters file://commands.params.json \
            --comment "TickTock bootstrap via SSM" \
            --timeout-seconds 1200 >/tmp/ssm_cmd.json
          CMD_ID=$(jq -r '.Command.CommandId' /tmp/ssm_cmd.json)
          echo "SSM Command ID: $CMD_ID"
          aws ssm wait command-executed --region "$REGION" --command-id "$CMD_ID" --instance-id "$IID"
