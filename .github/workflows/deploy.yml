name: Deploy Frontend and Backend

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  # Frontend (must be us-east-1 for CloudFront ACM)
  FRONTEND_REGION: ${{ vars.FRONTEND_REGION || 'us-east-1' }}
  FRONTEND_STACK_NAME: ${{ vars.FRONTEND_STACK_NAME || 'ttt-frontend' }}
  DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}
  INCLUDE_WWW: ${{ vars.INCLUDE_WWW || 'true' }}

  # Backend
  BACKEND_REGION: ${{ vars.BACKEND_REGION || 'us-east-1' }}
  BACKEND_STACK_NAME: ${{ vars.BACKEND_STACK_NAME || 'ttt-backend' }}
  VPC_ID: ${{ vars.VPC_ID }}
  SUBNET_ID: ${{ vars.SUBNET_ID }}
  API_SUBDOMAIN: ${{ vars.API_SUBDOMAIN || 'api' }}

jobs:
  deploy:
    name: Deploy stacks and link frontend
    runs-on: ubuntu-latest
    permissions:
      id-token: write    # for AWS OIDC federation
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (us-east-1)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.FRONTEND_REGION }}

      - name: Resolve Domain and Hosted Zone (fallbacks)
        run: |
          set -e
          # Ensure jq is installed for JSON parsing
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi
          # If DOMAIN_NAME/HOSTED_ZONE_ID are not provided as repo variables, try to infer them from the existing frontend stack or Route53
          MISSING_DOMAIN="${DOMAIN_NAME:-}"
          MISSING_ZONE="${HOSTED_ZONE_ID:-}"
          FRONT_STACK="${FRONTEND_STACK_NAME}"

          if [ -z "$MISSING_DOMAIN" ] || [ -z "$MISSING_ZONE" ]; then
            if aws cloudformation describe-stacks --region "$FRONTEND_REGION" --stack-name "$FRONT_STACK" >/dev/null 2>&1; then
              DN=$(aws cloudformation describe-stacks \
                --region "$FRONTEND_REGION" \
                --stack-name "$FRONT_STACK" \
                --query "Stacks[0].Parameters[?ParameterKey=='DomainName'].ParameterValue | [0]" \
                --output text)
              HZ=$(aws cloudformation describe-stacks \
                --region "$FRONTEND_REGION" \
                --stack-name "$FRONT_STACK" \
                --query "Stacks[0].Parameters[?ParameterKey=='HostedZoneId'].ParameterValue | [0]" \
                --output text)
              if [ -z "$MISSING_DOMAIN" ] && [ -n "$DN" ] && [ "$DN" != "None" ]; then
                echo "DOMAIN_NAME=$DN" >> "$GITHUB_ENV"
                MISSING_DOMAIN="$DN"
              fi
              if [ -z "$MISSING_ZONE" ] && [ -n "$HZ" ] && [ "$HZ" != "None" ]; then
                echo "HOSTED_ZONE_ID=$HZ" >> "$GITHUB_ENV"
                MISSING_ZONE="$HZ"
              fi

              # If still missing DomainName, try derive from BucketName output (<DomainName>-site)
              if [ -z "$MISSING_DOMAIN" ]; then
                BUCKET=$(aws cloudformation describe-stacks \
                  --region "$FRONTEND_REGION" \
                  --stack-name "$FRONT_STACK" \
                  --query "Stacks[0].Outputs[?OutputKey=='BucketName'].OutputValue | [0]" \
                  --output text)
                if [ -n "$BUCKET" ] && [ "$BUCKET" != "None" ]; then
                  if [ "${BUCKET##*-}" = "site" ]; then
                    DN2="${BUCKET%-site}"
                    echo "DOMAIN_NAME=$DN2" >> "$GITHUB_ENV"
                    MISSING_DOMAIN="$DN2"
                  fi
                fi
              fi
            fi

            # If we have DomainName but not HostedZoneId, look it up in Route53
            if [ -z "$MISSING_ZONE" ] && [ -n "$MISSING_DOMAIN" ]; then
              HZ2=$(aws route53 list-hosted-zones-by-name --dns-name "${MISSING_DOMAIN}." --query "HostedZones[0].Id" --output text 2>/dev/null || true)
              HZ2=${HZ2#/hostedzone/}
              if [ -n "$HZ2" ] && [ "$HZ2" != "None" ]; then
                echo "HOSTED_ZONE_ID=$HZ2" >> "$GITHUB_ENV"
                MISSING_ZONE="$HZ2"
              fi
            fi
          fi

          # If still missing both or one of them, try to infer from Route53 hosted zones
          if [ -z "$MISSING_DOMAIN" ] || [ -z "$MISSING_ZONE" ]; then
            # List public hosted zones
            ZONES_JSON=$(aws route53 list-hosted-zones --query "HostedZones[?Config.PrivateZone==\`false\`]")
            COUNT=$(echo "$ZONES_JSON" | jq 'length')
            if [ "$COUNT" -gt 0 ]; then
              # Choose the first zone; if only one exists, it's unambiguous
              Z_NAME=$(echo "$ZONES_JSON" | jq -r '.[0].Name' | sed 's/\.$//')
              Z_ID=$(echo "$ZONES_JSON" | jq -r '.[0].Id' | sed 's#.*/##')
              if [ -z "$MISSING_DOMAIN" ] && [ -n "$Z_NAME" ] && [ "$Z_NAME" != "null" ]; then
                echo "DOMAIN_NAME=$Z_NAME" >> "$GITHUB_ENV"
                MISSING_DOMAIN="$Z_NAME"
              fi
              if [ -z "$MISSING_ZONE" ] && [ -n "$Z_ID" ] && [ "$Z_ID" != "null" ]; then
                echo "HOSTED_ZONE_ID=$Z_ID" >> "$GITHUB_ENV"
                MISSING_ZONE="$Z_ID"
              fi
              echo "Route53 fallback used. Chosen zone: $Z_NAME ($Z_ID)" >> $GITHUB_STEP_SUMMARY
              if [ "$COUNT" -gt 1 ]; then
                echo "Warning: Multiple public hosted zones detected; selected the first. Set repo Variables DOMAIN_NAME and HOSTED_ZONE_ID to override." >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi

          # Ensure INCLUDE_WWW default if unset
          if [ -z "${INCLUDE_WWW:-}" ]; then echo "INCLUDE_WWW=true" >> "$GITHUB_ENV"; fi

          # Summarize resolution
          echo "Resolved DOMAIN_NAME=${MISSING_DOMAIN:-<unset>}" >> $GITHUB_STEP_SUMMARY
          echo "Resolved HOSTED_ZONE_ID=${MISSING_ZONE:-<unset>}" >> $GITHUB_STEP_SUMMARY

      - name: Validate required variables
        run: |
          set -e
          for v in DOMAIN_NAME HOSTED_ZONE_ID VPC_ID SUBNET_ID; do
            if [ -z "${!v}" ]; then echo "Missing required repo variable: $v"; exit 2; fi
          done

      - name: Deploy frontend stack (S3 + CloudFront + ACM + Route53)
        run: |
          aws cloudformation deploy \
            --region "${FRONTEND_REGION}" \
            --stack-name "${FRONTEND_STACK_NAME}" \
            --template-file infra/frontend/template.yaml \
            --parameter-overrides \
              DomainName="${DOMAIN_NAME}" \
              HostedZoneId="${HOSTED_ZONE_ID}" \
              IncludeWww="${INCLUDE_WWW}" \
            --capabilities CAPABILITY_NAMED_IAM

      - name: Get frontend outputs
        id: front
        run: |
          BUCKET=$(aws cloudformation describe-stacks \
            --region "${FRONTEND_REGION}" \
            --stack-name "${FRONTEND_STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='BucketName'].OutputValue | [0]" \
            --output text)
          DIST_ID=$(aws cloudformation describe-stacks \
            --region "${FRONTEND_REGION}" \
            --stack-name "${FRONTEND_STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='DistributionId'].OutputValue | [0]" \
            --output text)
          CF_DOMAIN=$(aws cloudformation describe-stacks \
            --region "${FRONTEND_REGION}" \
            --stack-name "${FRONTEND_STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='DistributionDomainName'].OutputValue | [0]" \
            --output text)
          echo "bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "dist_id=$DIST_ID" >> "$GITHUB_OUTPUT"
          echo "cf_domain=$CF_DOMAIN" >> "$GITHUB_OUTPUT"

      - name: Sync site to S3 bucket
        run: |
          set -e
          BUCKET='${{ steps.front.outputs.bucket }}'
          if [ -z "$BUCKET" ] || [ "$BUCKET" = "None" ]; then echo "Bucket not resolved"; exit 3; fi
          # Upload site (exclude infra, server, node_modules, etc.)
          aws s3 sync . "s3://$BUCKET" \
            --delete \
            --exclude ".git/*" \
            --exclude ".github/*" \
            --exclude "infra/*" \
            --exclude "mobile/*" \
            --exclude "node_modules/*" \
            --exclude "server/*" \
            --exclude "serverless/*"

      - name: Compute AllowedOrigins for backend
        id: origins
        run: |
          CF_DOMAIN='${{ steps.front.outputs.cf_domain }}'
          AO="https://${DOMAIN_NAME}"
          if [ "${INCLUDE_WWW}" = "true" ]; then AO="$AO,https://www.${DOMAIN_NAME}"; fi
          if [ -n "$CF_DOMAIN" ] && [ "$CF_DOMAIN" != "None" ]; then AO="$AO,https://$CF_DOMAIN"; fi
          echo "allowed=$AO" >> "$GITHUB_OUTPUT"

      - name: Ensure helper scripts are executable
        run: |
          chmod +x infra/scripts/deploy-backend.sh || true
          chmod +x infra/scripts/link-frontend.sh || true

      - name: Deploy backend stack (EC2 + Caddy TLS)
        run: |
          # Use repository URL (must be public for EC2 to clone)
          REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git"
          ./infra/scripts/deploy-backend.sh \
            "${BACKEND_STACK_NAME}" \
            "${DOMAIN_NAME}" \
            "${HOSTED_ZONE_ID}" \
            "${VPC_ID}" \
            "${SUBNET_ID}" \
            "${{ steps.origins.outputs.allowed }}" \
            "${API_SUBDOMAIN}" \
            "$REPO_URL" \
            "${BACKEND_REGION}"

      - name: Link frontend to backend endpoint (write config.js)
        run: |
          ./infra/scripts/link-frontend.sh "${FRONTEND_STACK_NAME}" "${BACKEND_STACK_NAME}" "${FRONTEND_REGION}"

      - name: Output Summary
        run: |
          echo "Frontend Bucket: ${{ steps.front.outputs.bucket }}" >> $GITHUB_STEP_SUMMARY
          echo "CloudFront ID: ${{ steps.front.outputs.dist_id }}" >> $GITHUB_STEP_SUMMARY
          echo "CloudFront Domain: ${{ steps.front.outputs.cf_domain }}" >> $GITHUB_STEP_SUMMARY
          echo "Allowed Origins: ${{ steps.origins.outputs.allowed }}" >> $GITHUB_STEP_SUMMARY
          BE_URL=$(aws cloudformation describe-stacks \
            --region "${BACKEND_REGION}" \
            --stack-name "${BACKEND_STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='BackendEndpoint'].OutputValue | [0]" \
            --output text)
          echo "Backend Endpoint: ${BE_URL}" >> $GITHUB_STEP_SUMMARY
