AWSTemplateFormatVersion: '2010-09-09'
Description: TickTock Tasks â€” Single EC2 with Elastic IP (frontend+backend via Docker Compose). Route53 apex and API records point directly to the EIP.

Parameters:
  AccountId:
    Type: String
  Region:
    Type: String
  DomainName:
    Type: String
  HostedZoneId:
    Type: String
  InstanceType:
    Type: String
    Default: t3.micro
  ApiSubdomain:
    Type: String
    Default: api
  WwwSubdomain:
    Type: String
    Default: ''
  RepoUrl:
    Type: String
  KeyName:
    Type: String
    Default: ''

Mappings:
  RegionMap:
    us-east-1:
      Ami: ami-0c02fb55956c7d316
    us-east-2:
      Ami: ami-024e6efaf93d85776
    us-west-2:
      Ami: ami-08970fb2e5767e3b8

Resources:
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub 'ttt-vpc-${DomainName}'

  InternetGateway:
    Type: AWS::EC2::InternetGateway

  VpcGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref Vpc

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref Vpc
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub 'ttt-public-${DomainName}'

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref Vpc

  DefaultRouteToInternet:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: EC2 SG allowing HTTP/HTTPS (SSH only if KeyName provided)
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  SshIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Condition: HasKeyName
    Properties:
      GroupId: !Ref InstanceSecurityGroup
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      CidrIp: 0.0.0.0/0

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: CloudWatchLogsAndECRPull
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: '*'
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: '*'
              - Effect: Allow
                Action:
                  - route53:ListHostedZones
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
                  - route53:GetChange
                Resource: '*'
  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [!Ref InstanceRole]

  Ec2Instance:
    Type: AWS::EC2::Instance
    Properties:
      IamInstanceProfile: !Ref InstanceProfile
      ImageId: !FindInMap [RegionMap, !Ref AWS::Region, Ami]
      InstanceType: !Ref InstanceType
      SubnetId: !Ref PublicSubnet
      SecurityGroupIds: [!Ref InstanceSecurityGroup]
      KeyName: !If [HasKeyName, !Ref KeyName, !Ref AWS::NoValue]
      Tags:
        - Key: Name
          Value: !Sub 'ttt-app-${DomainName}'
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -euxo pipefail
          exec >/var/log/ttt-userdata.log 2>&1
          yum update -y
          amazon-linux-extras install docker -y || true
          yum install -y docker git curl jq cronie
          systemctl enable docker
          systemctl start docker
          curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          # App checkout
          mkdir -p /opt/app
          if [ ! -d /opt/app/.git ]; then
            rm -rf /opt/app
            git clone ${RepoUrl} /opt/app
          fi
          cd /opt/app
          # Prepare cert and ACME folders for bind mounts
          mkdir -p /opt/app/letsencrypt /opt/app/certbot_challenges
          # Write compose env
          cat > .env <<EOF
          DOMAIN_NAME=${DomainName}
          CORS_ORIGIN=http://${DomainName},https://${DomainName}
          AWS_REGION=${Region}
          DDB_REGION=${Region}
          EOF
          # Pull images
          /usr/local/bin/docker-compose pull || true
          # Issue/renew certificates via Certbot (Route53 DNS validation)
          # Use the official Certbot image with dns-route53 plugin
          CERTBOT_DOCKER="docker run --rm -e AWS_REGION=${Region} -e AWS_DEFAULT_REGION=${Region} -v /opt/app/letsencrypt:/etc/letsencrypt -v /opt/app/certbot_challenges:/var/www/certbot certbot/dns-route53"
          $CERTBOT_DOCKER certonly --dns-route53 \
            -d ${DomainName} \
            -d www.${DomainName} \
            -d ${ApiSubdomain}.${DomainName} \
            -d www.${ApiSubdomain}.${DomainName} \
            --non-interactive --agree-tos -m admin@${DomainName} || true
          # Start the stack
          /usr/local/bin/docker-compose up -d
          # Install renewal cron to run twice daily and reload nginx if changed
          cat >/etc/cron.d/ttt-cert-renew <<CRON
          SHELL=/bin/bash
          PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
          MAILTO=""
          17 3,15 * * * root docker run --rm -e AWS_REGION=${Region} -e AWS_DEFAULT_REGION=${Region} -v /opt/app/letsencrypt:/etc/letsencrypt -v /opt/app/certbot_challenges:/var/www/certbot certbot/dns-route53 renew --quiet --deploy-hook 'docker exec ttt-nginx nginx -s reload' >>/var/log/ttt-certbot-renew.log 2>&1
          CRON
          chmod 644 /etc/cron.d/ttt-cert-renew
          systemctl enable crond || systemctl enable cronie || true
          systemctl start crond || systemctl start cronie || true

  Eip:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  EipAssociation:
    Type: AWS::EC2::EIPAssociation
    Properties:
      AllocationId: !GetAtt Eip.AllocationId
      InstanceId: !Ref Ec2Instance

  DnsRecordApex:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref DomainName
      Type: A
      TTL: '60'
      ResourceRecords:
        - !GetAtt Eip.PublicIp

  DnsRecordApi:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub '${ApiSubdomain}.${DomainName}'
      Type: A
      TTL: '60'
      ResourceRecords:
        - !GetAtt Eip.PublicIp

  DnsRecordWwwApex:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub 'www.${DomainName}'
      Type: A
      TTL: '60'
      ResourceRecords:
        - !GetAtt Eip.PublicIp

  DnsRecordWwwApi:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub 'www.${ApiSubdomain}.${DomainName}'
      Type: A
      TTL: '60'
      ResourceRecords:
        - !GetAtt Eip.PublicIp

Conditions:
  HasKeyName: !Not [!Equals [!Ref KeyName, ""]]

Outputs:
  PublicIp:
    Value: !Ref Eip
  ApexDomain:
    Value: !Ref DomainName
  ApiDomain:
    Value: !Sub '${ApiSubdomain}.${DomainName}'
  InstanceId:
    Value: !Ref Ec2Instance
